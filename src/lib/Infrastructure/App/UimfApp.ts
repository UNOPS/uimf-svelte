import type { IFormLinkData } from '../../Outputs/FormLink/FormLink.svelte';
import type AppStorage from '../Storage/App/AppStorage';
import type { FormInstance } from '../FormInstance';
import type { IFieldMetadata } from '../Metadata/IFieldMetadata';
import type { FormMetadata } from '../Metadata/FormMetadata';
import { FormResponse } from './FormResponse';
import { IFormContainer } from './IFormContainer';
import { FormLink } from '../Metadata';
import { IFormlinkBase } from '../../Outputs/FormLink/IFormlinkBase';
import { ResponseHandlerRegistry } from '../ResponseHandlers/ResponseHandlerRegistry';

interface IConfirmOptions {
    headerText?: string;
    bodyText: string;
    actionButtonText?: string;
    closeButtonText?: string;
}

interface IAlertOptions {
    headerText?: string;
    bodyText: string;
    actions?: FormLink[] | null;
    afterExceptionAction?: () => void;
    closeButtonText?: string;
    size?: string;
    cssClass?: string;
}

interface IModalOptions {
    form: string;
    inputFieldValues?: any;
    closeOnResponseHandled?: boolean;
    init?: (form: FormInstance, modal: { $close: () => void }) => void;
    parentForm?: IFormContainer | null;
}

interface IHtmlModalOptions {
    templateUrl: string;
    controller?: any;
    data?: any;
    size?: string;
    windowClass?: string;
}

interface ColorOptions {
    format: string;
    hue?: string;
    alpha: number;
    luminosity: string;
}

interface IPostFormConfig {
    afterExceptionAction?: () => void;
    skipClientFunctions?: boolean;
}

export class UimfApp {
    constructor(app: AppObject) {
        this.appStorage = app.appStorage;
        this.#app = app;
        this.formsById = app.formsById;
    }

    #app: AppObject;
    appStorage: AppStorage;
    formsById: { [id: string]: FormMetadata };

    // Exception types that are at the beginning of the list have higher priority.
    private exceptionConfigs = [
        { type: 'UNWB.Business.Exceptions.BusinessException', showPreamble: false },
        { type: 'UNWB.Business.Exceptions.PermissionException', showPreamble: true },
        { type: 'UNWB.Agresso.AgressoException', showPreamble: true },
        { type: 'System.ApplicationException', showPreamble: true },
        { type: 'System.Data.SqlClient.SqlException', showPreamble: true }
    ];

    private currentlyShownExceptions: { [key: string]: boolean } = {};

    private preamble =
        'An error occured. If you need assistance please contact us at unwebbuyplus@unops.org.<br><br>';

    private formPromises: { [formId: string]: Promise<FormMetadata> } = {};

    renderForm(options: { data: any; metadata: IFieldMetadata; form: FormInstance | null }): Element {
        return this.#app.renderForm(options);
    }
    runResponseHandler(response: FormResponse): Promise<void> {
        if (response.Metadata != null) {
            const customHandler = this.getResponseHandler(response.Metadata.Handler);
            if (customHandler != null && typeof customHandler === 'function') {
                customHandler(response);
            }
        }

        return Promise.resolve();
    }

    /**
     * Runs client functions defined in the response metadata. Client functions
     * are run sequentially in the order they are defined in the response metadata.
     * @param response Response object generated by `parentForm`.
     * @param parentForm Form instance from which the `response` parameter is coming.
     * @returns {*} A promise that resolves when all client functions have been run.
     */
    runClientFunctions(response: FormResponse, parentForm?: FormInstance | null): Promise<void> {
        const functionsToRun = (response.Metadata || ({} as any)).FunctionsToRun || [];

        const runNext = (i: number): Promise<void> => {
            if (i >= functionsToRun.length) {
                return Promise.resolve();
            }

            const toRun = functionsToRun[i];

            let fn: any = null;
            let entry: any = null;

            entry = (window as any).SvelteComponents?.ClientFunctionRegistry?.[toRun.Id];
            if (entry != null) {

                if (typeof entry === 'function') {
                    fn = entry;
                }

                else if (typeof entry.handle === 'function') {
                    fn = (params?: any) => entry.handle(params);
                }
            }

            if (fn == null) {
                return Promise.reject('Cannot find client function "' + toRun.Id + '".');
            }

            const result = fn({
                functionToRun: toRun,
                response: response,
                parentForm: parentForm,
                uimfApp: this
            });

            return Promise.resolve(result).then((data) => {
                if (data != null && data.isError === true) {
                    return Promise.reject();
                } else {
                    return runNext(i + 1);
                }
            }).catch((err) => {
                console.error('[UimfApp.ts runClientFunctions] Error in function:', toRun.Id, err);
                return Promise.reject(err);
            });
        };

        return runNext(0);
    }

    handleCustomFormLinkAction(value: IFormLinkData, inputFieldValues: any): void {
        const handler = this.getFormLinkActionHandler(value.Action);
        if (handler == null) {
            throw 'Unsupported action: ' + value.Action;
        }

        handler(value, inputFieldValues);
    }
    confirm(options: IConfirmOptions): Promise<void> {
        return this.#app.confirm(options);
    }
    alert(options: IAlertOptions): Promise<void> {
        return this.#app.alert(options);
    }
    openModal(options: IModalOptions): Promise<void> {
        return this.#app.openModal(options);
    }
    openHtmlModal(options: IHtmlModalOptions): Promise<void> {
        return this.#app.openHtmlModal(options);
    }
    makeUrl(link: IFormlinkBase): Promise<string> {
        if (link.Action === 'redirect-to-url') {
            return Promise.resolve((link.InputFieldValues || {})['url']);
        } else if (link.Action === 'generate-pdf') {
            return Promise.resolve(link.Form || '');
        }

        return this.getFormMetadata(link.Form || '').then((metadata) => {
            const params = link.InputFieldValues || {};

            let query = '';
            const sortedKeys = Object.keys(params).sort();

            for (let i = 0; i < sortedKeys.length; i++) {
                const key = sortedKeys[i];
                const inputValue = params[key];

                if (inputValue == null) {
                    continue;
                }

                const inputMetadata = metadata.InputFields.find((t) => t.Id === key);

                const serializedValue = this.serializeInputValue(inputMetadata, inputValue);

                if (serializedValue != null && serializedValue !== '') {
                    if (query !== '') {
                        query += '&';
                    }
                    query += encodeURIComponent(key) + '=' + encodeURIComponent(serializedValue);
                }
            }

            let url = '#/form/' + link.Form;

            if (query) {
                // We add the _ query parameter to make sure the URL is reloaded
                // in case the non-query part of the URL is identical to the current one.
                // For example if we try to navigate from `/form/user?id=1` to `/form/user?id=2`
                // the route won't reload (even though state's `reloadOnSearch` is set to `true`).
                // To force the route reload we need to add a `_` query parameter with a value that's
                // different from the current route, i.e. - the target url should be something like
                // `/form/user?id=2&_=1`.
                // To make sure `_` doesn't get too long we limit it to values between 0 and 99.
                // This is a purely aesthetic concern.
                let counter = 0;
                if (typeof window !== 'undefined') {
                    const hash = window.location.hash || '';
                    const queryStart = hash.indexOf('?');
                    if (queryStart !== -1) {
                        const hashQuery = hash.substring(queryStart + 1);
                        const hashParams = new URLSearchParams(hashQuery);
                        const current = parseInt(hashParams.get('_') || '0', 10);
                        counter = isNaN(current) ? 0 : current + 1;
                    }
                }
                url += '?' + query + '&_=' + counter;
            }

            return url;
        });
    }
    goto(link: FormLink): Promise<void> {
        return this.makeUrl(link as any).then((url) => {
            window.location.href = url;
        });
    }
    postForm<T extends FormResponse>(
        form: string,
        data: any,
        config: IPostFormConfig | null
    ): Promise<T> {

        config = config || {};

        const headers: any = {
            'Content-Type': 'application/json',
            uimf: 'true'
        };

        // Only add token if we're on the external site (internal site has ngStorage-internaluser)
        const isInternalSite = localStorage.getItem('ngStorage-internaluser') != null;
        if (!isInternalSite) {
            const token = localStorage.getItem('Token');
            if (token) {
                headers.Authorization = 'Bearer ' + token;
            }
        }

        return fetch('/api/form/run', {
            method: 'POST',
            headers: headers,
            credentials: 'include',
            body: JSON.stringify([
                {
                    Form: form,
                    InputFieldValues: data
                }
            ])
        })
            .then((response) => {
                if (!response.ok) {
                    return response.json().then((errorData) => {
                        this.handleErrorHttpResponse(errorData, config!);
                        return Promise.reject(errorData);
                    });
                }
                return response.json();
            })
            .then((responseArray: any[]) => {

                const clientFunctionsPromise = !config!.skipClientFunctions
                    ? this.runClientFunctions(responseArray[0].Data, (config as any).parentForm)
                    : Promise.resolve();

                return clientFunctionsPromise.then(() => {
                    return responseArray[0].Data as T;
                }).catch((error) => {
                    return Promise.reject(responseArray);
                });
            });
    }
    getApiFile(url: string): Promise<void> | void {
        // Check if we're on the internal site
        const isInternalSite = localStorage.getItem('ngStorage-internaluser') != null;

        if (isInternalSite) {
            // On internal site, just open the file in a new window
            window.open(url);
            return;
        }

        // On external site, fetch with token
        const token = localStorage.getItem('Token');
        if (token == null) {
            // No token available, open in new window as fallback
            window.open(url);
            return;
        }

        return fetch(url, {
            method: 'GET',
            headers: {
                uimf: 'true',
                Authorization: 'Bearer ' + token
            }
        }).then((response) => {
            response.blob().then((blob) => {
                const fileUrl = URL.createObjectURL(blob);

                const fileLink = document.createElement('a');
                fileLink.href = fileUrl;
                fileLink.download = response.headers.get('Content-Disposition')!.split('filename=')[1];
                fileLink.click();

                // Release the file a little later, to ensure it was downloaded before we do so.
                setTimeout(() => {
                    URL.revokeObjectURL(fileUrl);
                }, 30000);
            });
        });
    }
    getApi(url: string): Promise<any> {
        const headers: any = {
            uimf: 'true'
        };

        // Only add token if we're on the external site (internal site has ngStorage-internaluser)
        const isInternalSite = localStorage.getItem('ngStorage-internaluser') != null;
        if (!isInternalSite) {
            const token = localStorage.getItem('Token');
            if (token) {
                headers.Authorization = 'Bearer ' + token;
            }
        }

        return fetch(url, {
            headers: headers,
            credentials: 'include'
        })
            .then((response) => {
                if (!response.ok) {
                    return response.json().then((errorData) => {
                        this.handleErrorHttpResponse(errorData);
                        throw errorData;
                    });
                }
                return response.json();
            })
            .catch((error) => {
                throw error;
            });
    }
    postApi(url: string, data: any, options?: any): Promise<any> {
        const headers: any = {
            'Content-Type': 'application/json',
            uimf: 'true'
        };

        // Only add token if we're on the external site (internal site has ngStorage-internaluser)
        const isInternalSite = localStorage.getItem('ngStorage-internaluser') != null;
        if (!isInternalSite) {
            const token = localStorage.getItem('Token');
            if (token) {
                headers.Authorization = 'Bearer ' + token;
            }
        }

        return fetch(url, {
            method: 'POST',
            headers: headers,
            credentials: 'include',
            body: JSON.stringify(data)
        })
            .then((response) => {
                if (!response.ok) {
                    return response.json().then((errorData) => {
                        this.handleErrorHttpResponse(errorData, options);
                        throw errorData;
                    });
                }
                // Check if response has content before parsing JSON
                return response.text().then((text) => {
                    return text ? JSON.parse(text) : null;
                });
            })
            .catch((error) => {
                throw error;
            });
    }
    getResponseHandler(handler: string) {
        return ResponseHandlerRegistry[handler];
    }
    getClientFunction(id: string) {
        const entry = (window as any).SvelteComponents?.ClientFunctionRegistry?.[id];
        if (entry != null) {
            if (typeof entry === 'function') {
                return entry;
            }

            if (typeof entry?.handle === 'function') {
                return (params?: any) => entry.handle(params);
            }
        }
        return null;
    }
    getFormLinkActionHandler(action: string) {
        return this.#app.getFormLinkActionHandler(action);
    }
    serializeInputValue(metadata: any, value: any) {
        if ((window as any).SvelteComponents.controlRegister.inputs[metadata.Component.Type] != null) {
            const controller = new (window as any).SvelteComponents.controlRegister.inputs[
                metadata.Component.Type
            ].controller({
                metadata: metadata,
                app: this
            });

            return controller.serialize(value);
        }

        // AngularJS input components just use basic serialization.
        return value == null ? null : value.toString();
    }
    getFormMetadata(formId: string): Promise<FormMetadata> {
        if (this.formPromises[formId] != null) {
            return this.formPromises[formId];
        }

        const headers: any = {
            uimf: 'true'
        };

        // Only add token if we're on the external site (internal site has ngStorage-internaluser)
        const isInternalSite = localStorage.getItem('ngStorage-internaluser') != null;
        if (!isInternalSite) {
            const token = localStorage.getItem('Token');
            if (token) {
                headers.Authorization = 'Bearer ' + token;
            }
        }

        const promise = fetch('/api/form/metadata/' + formId, {
            headers: headers,
            credentials: 'include'
        })
            .then((response) => {
                if (!response.ok) {
                    return response.json().then((errorData) => {
                        this.handleErrorHttpResponse(errorData);
                        throw errorData;
                    });
                }
                return response.json();
            })
            .then((metadata: FormMetadata) => {
                if (metadata == null) {
                    console.error('Cannot find form metadata for "' + formId + '".');
                    throw metadata;
                }

                this.formsById[formId] = metadata;
                return metadata;
            })
            .catch((error) => {
                throw error;
            });

        this.formPromises[formId] = promise;

        return promise;
    }
    getForm(formId: string): Promise<FormInstance> {
        return this.#app.getForm(formId);
    }
    hasPermission(permission?: string | null): boolean {
        return this.#app.hasPermission(permission);
    }
    colorFromString(str: string, options?: ColorOptions | null): string {
        return this.#app.colorFromString(str, options);
    }
    getDefaultValue(valueName: string) {
        switch (valueName) {
            case 'currentUser':
                const internalUser = localStorage.getItem('ngStorage-internaluser');
                if (internalUser) {
                    try {
                        const parsed = JSON.parse(internalUser);
                        return parsed?.Id;
                    } catch (e) {
                        // JSON parsing failed, return null
                        return null;
                    }
                }
                return null;
            default:
                return valueName;
        }
    }
    showFormInSection(
        formId: string,
        inputFieldValues: any,
        sectionId: string,
        visibleOnlyTo?: string[]
    ): void {
        return this.#app.showFormInSection(formId, inputFieldValues, sectionId, visibleOnlyTo);
    }

    getPriceData(product: any): any {
        return this.#app.getPriceData(product);
    }

    populateCart(shoppingCart: any): void {
        return this.#app.populateCart(shoppingCart);
    }

    buildFormUrl(form: string, data: any): string {
        const baseUrl = '#/form/' + form;
        const params: string[] = [];

        for (const key in data) {
            if (data.hasOwnProperty(key) && data[key] !== null) {
                if (typeof data[key] === 'object') {
                    params.push(key + '=' + encodeURIComponent(JSON.stringify(data[key])));
                } else {
                    params.push(key + '=' + encodeURIComponent(data[key]));
                }
            }
        }

        return baseUrl + '?' + params.join('&');
    }

    private handleErrorHttpResponse(response: any, options?: { afterExceptionAction?: () => void }): void {
        if (response.ExceptionType == null && response.InnerException == null) {
            return;
        }

        let exception = response || {};
        const stack: Array<{
            exception: any;
            priority: number;
            config: { type?: string; showPreamble?: boolean };
        }> = [];

        while (true) {
            const exceptionType = exception.ExceptionType || exception.ClassName;

            const priority = this.exceptionConfigs.findIndex((t) => t.type.indexOf(exceptionType) !== -1);

            const exceptionConfig = this.exceptionConfigs[priority];

            stack.push({
                exception: exception,
                // For exceptions that are not in the priority list we
                // prioritize exceptions at the top of the stack
                // and decrease priority with each inner exception.
                priority: priority === -1 ? 999 + stack.length : priority,
                config: exceptionConfig || {}
            });

            if (exception.InnerException == null) {
                break;
            }

            exception = exception.InnerException;
        }

        const stackItemToShow = stack.sort((a, b) => a.priority - b.priority)[0];

        exception = stackItemToShow.exception;

        let bodyText = stackItemToShow.config.showPreamble ? this.preamble : '';

        const exceptionMessage = exception.ExceptionMessage || exception.Message || '';

        if (exceptionMessage.length > 0) {
            if (stackItemToShow.config.showPreamble) {
                bodyText += "<div class='exception-details'>" + exceptionMessage + '</div>';
            } else {
                bodyText += exceptionMessage;
            }
        }

        if (bodyText.length === 0) {
            bodyText = this.preamble;
        }

        // If the exception is already shown, then don't show it again.
        if (this.currentlyShownExceptions[exceptionMessage] === true) {
            return;
        }

        this.currentlyShownExceptions[exceptionMessage] = true;

        const actions = (exception.Value || {}).Actions;

        this.#app
            .alert({
                headerText: 'Something went wrong...',
                bodyText: bodyText,
                actions: actions,
                afterExceptionAction: (options || {}).afterExceptionAction,
                closeButtonText: actions != null ? 'Cancel' : 'OK',
                size: 'lg',
                cssClass: 'px-3 py-1'
            })
            .finally(() => {
                // Indicate that the alert showing this exception message has been closed.
                this.currentlyShownExceptions[exceptionMessage] = false;
            });
    }
}

interface AppObject {
    appStorage: AppStorage;
    showFormInSection(
        formId: string,
        inputFieldValues: any,
        sectionId: string,
        visibleOnlyTo?: string[]
    ): void;
    renderForm(options: { data: any; metadata: IFieldMetadata; form: FormInstance | null }): Element;
    runClientFunctions(response: FormResponse, parentForm?: FormInstance | null): Promise<void>;
    handleCustomFormLinkAction(value: IFormLinkData, inputFieldValues: any): void;
    confirm(options: IConfirmOptions): Promise<void>;
    alert(options: IAlertOptions): Promise<void>;
    openModal(options: IModalOptions): Promise<void>;
    openHtmlModal(options: IHtmlModalOptions): Promise<void>;
    formsById: { [id: string]: FormMetadata };
    makeUrl(link: IFormlinkBase): Promise<string>;
    goto(link: FormLink): Promise<void>;
    postForm<T extends FormResponse>(
        form: string,
        data: any,
        config: IPostFormConfig | null
    ): Promise<T>;
    getApiFile(url: string): Promise<void> | void;
    getApi(url: string): Promise<any>;
    postApi(url: string, data: any, options?: any): Promise<any>;
    getClientFunction(id: string): any;
    getFormLinkActionHandler(action: string): any;
    getFormMetadata(formId: string): Promise<FormMetadata>;
    getForm(formId: string): Promise<FormInstance>;
    hasPermission(permission?: string | null): boolean;
    colorFromString(str: string, options?: ColorOptions | null): string;
    buildFormUrl(form: string, data: any): string;
    getPriceData(product: any): any;
    populateCart(shoppingCart: any): void;
}
